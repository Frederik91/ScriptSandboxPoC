using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace ScriptBox.SemanticKernel;

/// <summary>
/// Generates TypeScript declaration files that describe the ScriptBox Semantic Kernel surface.
/// </summary>
public static class SemanticKernelTypeScriptGenerator
{
    /// <summary>
    /// Generates the TypeScript declaration content for the provided namespaces.
    /// </summary>
    public static string Generate(IEnumerable<SemanticKernelNamespaceMetadata> namespaces)
    {
        if (namespaces is null)
        {
            throw new ArgumentNullException(nameof(namespaces));
        }

        var ordered = namespaces
            .Where(n => n is not null)
            .OrderBy(n => n.Name, StringComparer.Ordinal)
            .ToList();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This file was generated by ScriptBox.SemanticKernel.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("declare namespace ScriptBox {");

        foreach (var ns in ordered)
        {
            var interfaceName = BuildInterfaceName(ns.Name);
            sb.AppendLine($"  interface {interfaceName} {{");
            foreach (var method in ns.Functions.OrderBy(f => f.Name, StringComparer.Ordinal))
            {
                if (!string.IsNullOrWhiteSpace(method.Description))
                {
                    sb.AppendLine("    /**");
                    sb.AppendLine($"     * {method.Description}");
                    sb.AppendLine("     */");
                }

                var parameters = string.Join(", ", method.Parameters.Select(p =>
                {
                    var optionalSuffix = p.IsOptional ? "?" : string.Empty;
                    return $"{p.Name}{optionalSuffix}: {p.Type}";
                }));

                var returnType = method.ReturnsVoid
                    ? "Promise<void>"
                    : $"Promise<{method.ReturnType}>";

                sb.AppendLine($"    {method.Name}({parameters}): {returnType};");
            }

            sb.AppendLine("  }");
            sb.AppendLine();
        }

        sb.AppendLine("}");
        sb.AppendLine();

        foreach (var ns in ordered)
        {
            var interfaceName = BuildInterfaceName(ns.Name);
            sb.AppendLine($"declare const {ns.Name}: ScriptBox.{interfaceName};");
        }

        return sb.ToString();
    }

    /// <summary>
    /// Generates the declaration content and writes it to the specified file.
    /// </summary>
    public static async Task WriteToFileAsync(
        string filePath,
        IEnumerable<SemanticKernelNamespaceMetadata> namespaces,
        CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(filePath))
        {
            throw new ArgumentException("File path must be provided.", nameof(filePath));
        }

        var content = Generate(namespaces);
        await File.WriteAllTextAsync(filePath, content, Encoding.UTF8, cancellationToken)
            .ConfigureAwait(false);
    }

    private static string BuildInterfaceName(string jsNamespace)
    {
        if (string.IsNullOrWhiteSpace(jsNamespace))
        {
            return "Api";
        }

        var shouldUpper = true;
        var builder = new StringBuilder(jsNamespace.Length + 3);
        foreach (var ch in jsNamespace)
        {
            if (!char.IsLetterOrDigit(ch))
            {
                shouldUpper = true;
                continue;
            }

            builder.Append(shouldUpper ? char.ToUpperInvariant(ch) : ch);
            shouldUpper = false;
        }

        builder.Append("Api");
        return builder.ToString();
    }
}
